
//
//  KCSUser2+KinveyUserService.m
//  KinveyKit
//
//  Created by Michael Katz on 12/10/13.
//  Copyright (c) 2013-2014 Kinvey. All rights reserved.
//
// This software is licensed to you under the Kinvey terms of service located at
// http://www.kinvey.com/terms-of-use. By downloading, accessing and/or using this
// software, you hereby accept such terms of service  (and any agreement referenced
// therein) and agree that you have read, understand and agree to be bound by such
// terms of service and are of legal age to agree to such terms with Kinvey.
//
// This software contains valuable confidential and proprietary information of
// KINVEY, INC and is subject to applicable licensing agreements.
// Unauthorized reproduction, transmission or distribution of this file and its
// contents is a violation of applicable laws.
//

#import "KCSUser2+KinveyUserService.h"

#import "KinveyCoreInternal.h"
#import "KinveyDataStoreInternal.h"

KK2(Cleanup!)
#import "KinveyUser.h"
#import "KCSHiddenMethods.h"
#import "KCSDataModel.h"
#import "KCSPush.h"

#import "NSString+KinveyAdditions.h"
#import "NSURL+KinveyAdditions.h"

#import "KCSURLConnectionDelegateAdapter.h"

#define KCSEntityKeyKMD @"_kmd"
#define KCSEntityKeyAuthtoken @"authtoken"
#define KCSEntityKeyEmailVerification @"emailVerification"
#define KCSUserAttributePassword @"password"

NSString* const kKCSMICRefreshTokenKey = @"refresh_token";
NSString* const kKCSMICRedirectURIKey = @"redirect_uri";

@implementation KCSUser2 (KinveyUserService)

#pragma mark - Credential Management

+ (BOOL) hasSavedCredentials
{
    return [KCSKeychain2 hasTokens];
}

+ (BOOL) clearSavedCredentials
{
    return [KCSKeychain2 deleteTokens];
}

+ (void) setActive:(id<KCSUser2>)user
{
    KK2(manage active user here)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated"
    [KCSClient sharedClient].currentUser = (id)user;
#pragma clang diagnostic pop
}

+ (id<KCSUser2>)activeUser
{
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated"
    return (id)[KCSClient sharedClient].currentUser;
#pragma clang diagnostic pop
}

#pragma mark - User Creation

+ (void) createAutogeneratedUser:(NSDictionary *)fieldsAndValues completion:(KCSUser2CompletionBlock)completionBlock
{
    [self createUserWithUsername:nil password:nil fieldsAndValues:fieldsAndValues completion:completionBlock];
}

+ (void) createUserWithUsername:(NSString *)username password:(NSString *)password fieldsAndValues:(NSDictionary *)fieldsAndValues completion:(KCSUser2CompletionBlock)completionBlock
{
    if (!completionBlock) [[NSException exceptionWithName:NSInvalidArgumentException reason:@"Completion Block is nil" userInfo:nil] raise];
    if ((password == nil && username != nil) || (username == nil && password != nil)) {
        [[NSException exceptionWithName:NSInvalidArgumentException reason:@"Both username and password need to be set or both nil" userInfo:nil] raise];
    }
    
    NSMutableDictionary* createUserBody = [NSMutableDictionary dictionaryWithDictionary:fieldsAndValues];
    if (username && password) {
        createUserBody[KCSUserAttributeUsername] = username;
        createUserBody[KCSUserAttributePassword] = password;
    }
    
    KCSRequest2* request = [KCSRequest2 requestWithCompletion:^(KCSNetworkResponse *response, NSError *error) {
        if (error) {
            KCSLogNSError(KCS_LOG_CONTEXT_USER, error);
            [self setActive:nil];
            dispatch_async(dispatch_get_main_queue(), ^{
                completionBlock(nil, error);
            });
        } else {
            // Ok, we're really auth'd
            NSDictionary* userBody = [response jsonObject];
            [self setupActiveUser:userBody completion:completionBlock checkAuth:YES];
        }
    }
                                                        route:KCSRESTRouteUser
                                                      options:@{KCSRequestLogMethod}
                                                  credentials:[KCSClient2 sharedClient]];
    request.body = createUserBody;
    request.method = KCSRESTMethodPOST;
    [request start];
}

+ (void) createWithAuthProvider:(KCSUserSocialIdentifyProvider)provider loginBody:(NSDictionary*)body completion:(KCSUser2CompletionBlock)completionBlock;
{
    KCSRequest2* request = [KCSRequest2 requestWithCompletion:^(KCSNetworkResponse *response, NSError *error) {
        if (error) {
            KCSLogNSError(KCS_LOG_CONTEXT_USER, error);
            [self setActive:nil];
            dispatch_async(dispatch_get_main_queue(), ^{
                completionBlock(nil, error);
            });
        } else {
            // Ok, we're really auth'd
            NSDictionary* userBody = [response jsonObject];
            [self setupActiveUser:userBody completion:completionBlock checkAuth:YES];
        }
    }
                                                        route:KCSRESTRouteUser
                                                      options:@{KCSRequestLogMethod}
                                                  credentials:[KCSClient2 sharedClient]];
    request.method = KCSRESTMethodPOST;
    request.body = body;
    [request start];
}


#pragma mark - Login
+ (void)loginWithUsername:(NSString *)username password:(NSString *)password completion:(KCSUser2CompletionBlock)completionBlock
{
    if (!username) [[NSException exceptionWithName:NSInvalidArgumentException reason:@"username should not be nil." userInfo:nil] raise];
    if (!password) [[NSException exceptionWithName:NSInvalidArgumentException reason:@"password should not be nil." userInfo:nil] raise];
    
    KCSRequest2* request = [KCSRequest2 requestWithCompletion:^(KCSNetworkResponse *response, NSError *error) {
        if (error) {
            KCSLogNSError(KCS_LOG_CONTEXT_USER, error);
            [self setActive:nil];
            dispatch_async(dispatch_get_main_queue(), ^{
                completionBlock(nil, error);
            });
        } else {
            // Ok, we're really auth'd
            NSDictionary* userBody = [response jsonObject];
            [self setupActiveUser:userBody completion:completionBlock checkAuth:YES];
        }
    }
                                                        route:KCSRESTRouteUser
                                                      options:@{KCSRequestLogMethod}
                                                  credentials:[KCSClient2 sharedClient]];
    request.path = @[@"login"];
    request.method = KCSRESTMethodPOST;
    request.body = @{@"username":username, @"password":password};
    [request start];
}

+ (void)connectWithAuthProvider:(KCSUserSocialIdentifyProvider)provider
               accessDictionary:(NSDictionary*)accessDictionary
                     completion:(KCSUser2CompletionBlock)completionBlock
{
    NSDictionary* loginDict = [self loginDictForProvider:provider accessDictionary:accessDictionary];
    
    KCSRequest2* request = [KCSRequest2 requestWithCompletion:^(KCSNetworkResponse *response, NSError *error) {
        if (error) {
            if (response.isKCSError == YES && response.code == KCSNotFoundError) {
                //This is new user, create
                [self createWithAuthProvider:provider loginBody:loginDict completion:completionBlock];
            } else {
                KCSLogNSError(KCS_LOG_CONTEXT_USER, error);
                [self setActive:nil];
                dispatch_async(dispatch_get_main_queue(), ^{
                    completionBlock(nil, error);
                });
            }
        } else {
            // Ok, we're really auth'd
            NSMutableDictionary* userBody = [NSMutableDictionary dictionaryWithDictionary:[response jsonObject]];
            if (provider == KCSSocialIDKinvey) {
                NSMutableDictionary* kinveyAuth = [NSMutableDictionary dictionaryWithDictionary:userBody[@"_socialIdentity"][@"kinveyAuth"]];
                kinveyAuth[kKCSMICRedirectURIKey] = accessDictionary[kKCSMICRedirectURIKey];
                userBody[@"_socialIdentity"][@"kinveyAuth"] = kinveyAuth;
            }
            [self setupActiveUser:userBody completion:completionBlock checkAuth:YES];
        }
    }
                                                        route:KCSRESTRouteUser
                                                      options:@{KCSRequestLogMethod}
                                                  credentials:[KCSClient2 sharedClient]];
    request.path = @[@"login"];
    request.method = KCSRESTMethodPOST;
    request.body = loginDict;
    [request start];
}

+(void)loginWithMICRedirectURI:(NSString *)redirectURI
        authorizationGrantType:(KCSMICAuthorizationGrantType)authorizationGrantType
                       options:(NSDictionary *)optons
                    completion:(KCSUser2CompletionBlock)completionBlock
{
    NSURL* url = [self URLforLoginWithMICRedirectURI:redirectURI
                              authorizationGrantType:authorizationGrantType];
    switch (authorizationGrantType) {
        case KCSMICAuthorizationGrantTypeAuthCodeLoginPage:
        {
            [[UIApplication sharedApplication] openURL:url];
        }
            break;
        case KCSMICAuthorizationGrantTypeAuthCodeAPI:
        {
            NSMutableURLRequest* request = [KCSRequest2 requestForURL:url];
            request.HTTPMethod = @"POST";
            KCSClientConfiguration* config = [KCSClient2 sharedClient].configuration;
            if (!config) {
                config = [KCSClient sharedClient].configuration;
            }
            request.HTTPBody = [[self stringFromDictionaryURLEncode:@{
                @"client_id" : config.appKey,
                kKCSMICRedirectURIKey : redirectURI,
                @"response_type" : @"code"
            }] dataUsingEncoding:NSUTF8StringEncoding];
            
            [request setValue:@(request.HTTPBody.length).stringValue
           forHTTPHeaderField:@"Content-Length"];
            
            [request setValue:@"application/x-www-form-urlencoded"
           forHTTPHeaderField:@"Content-Type"];
            
            [NSURLConnection sendAsynchronousRequest:request
                                               queue:[KCSRequest2 requestQueue]
                                   completionHandler:^(NSURLResponse *response, NSData *data, NSError *error)
            {
                if (error) {
                    if (completionBlock) DISPATCH_ASYNC_MAIN_QUEUE(completionBlock(nil, error));
                } else if ([response isKindOfClass:[NSHTTPURLResponse class]]) {
                    NSHTTPURLResponse* httpResponse = (NSHTTPURLResponse*) response;
                    if (httpResponse.statusCode == 200 && data) {
                        NSDictionary* jsonResponse = [NSJSONSerialization JSONObjectWithData:data
                                                                                     options:0
                                                                                       error:&error];
                        if (error) {
                            if (completionBlock) DISPATCH_ASYNC_MAIN_QUEUE(completionBlock(nil, error));
                        } else {
                            [self oAuthAuthenticateWithURL:[NSURL URLWithString:jsonResponse[@"temp_login_uri"]]
                                               redirectURI:redirectURI
                                                   options:optons
                                                completion:completionBlock];
                        }
                    } else {
                        if (completionBlock) {
                            DISPATCH_ASYNC_MAIN_QUEUE(
                                completionBlock(
                                    nil,
                                    [NSError errorWithDomain:[NSHTTPURLResponse localizedStringForStatusCode:httpResponse.statusCode]
                                                        code:httpResponse.statusCode
                                                    userInfo:@{}]
                                )
                            );
                        }
                    }
                } else if (completionBlock) {
                    DISPATCH_ASYNC_MAIN_QUEUE(
                        completionBlock(
                            nil,
                            [NSError errorWithDomain:@"Bad Request"
                                                code:400
                                            userInfo:@{}]
                        )
                    );
                }
            }];
        }
            break;
        default:
            break;
    }
}

+(KCSClientConfiguration*)clientConfiguration
{
    KCSClientConfiguration* config = [KCSClient2 sharedClient].configuration;
    if (!config) {
        config = [KCSClient sharedClient].configuration;
    }
    return config;
}

+(void)oAuthAuthenticateWithURL:(NSURL*)url
                    redirectURI:(NSString *)redirectURI
                        options:(NSDictionary *)optons
                     completion:(KCSUser2CompletionBlock)completionBlock
{
    NSMutableURLRequest* request = [KCSRequest2 requestForURL:url];
    request.HTTPMethod = @"POST";
    request.HTTPBody = [[self stringFromDictionaryURLEncode:@{
        @"client_id" : [self clientConfiguration].appKey,
        kKCSMICRedirectURIKey : redirectURI,
        @"response_type" : @"code",
        KCSUsername : optons[KCSUsername],
        KCSPassword : optons[KCSPassword]
    }] dataUsingEncoding:NSUTF8StringEncoding];
    
    [request setValue:@(request.HTTPBody.length).stringValue
   forHTTPHeaderField:@"Content-Length"];
    
    [request setValue:@"application/x-www-form-urlencoded"
   forHTTPHeaderField:@"Content-Type"];
    
    __block NSURLRequest* redirectRequest = nil;
    KCSURLConnectionDelegateAdapter* connectionDelegateAdapter = [[KCSURLConnectionDelegateAdapter alloc] init];
    [connectionDelegateAdapter setConnectionWillSendRequestRedirectResponse:^NSURLRequest *(NSURLConnection *connection, NSURLRequest *request, NSURLResponse *response) {
        if (response) {
            redirectRequest = request;
            return nil;
        }
        
        return request;
    }];
    [connectionDelegateAdapter setCompletionBlock:^(NSURLResponse *response, NSData *data, NSError *error) {
        if (error) {
            if (completionBlock) DISPATCH_ASYNC_MAIN_QUEUE(completionBlock(nil, error));
        } else if ([response isKindOfClass:[NSHTTPURLResponse class]]) {
            NSHTTPURLResponse* httpResponse = (NSHTTPURLResponse*) response;
            if (httpResponse.statusCode == 302) { //redirect
                if (error) {
                    if (completionBlock) DISPATCH_ASYNC_MAIN_QUEUE(completionBlock(nil, error));
                } else {
                    if ([self isValidMICRedirectURI:redirectURI
                                              forURL:redirectRequest.URL]) {
                        [self parseMICRedirectURI:redirectURI
                                           forURL:redirectRequest.URL
                              withCompletionBlock:completionBlock];
                    } else {
                        DISPATCH_ASYNC_MAIN_QUEUE(completionBlock(nil, [NSError errorWithDomain:@"Invalid MIC Redirect URL"
                                                                                           code:400
                                                                                       userInfo:@{}]));
                    }
                }
            } else {
                if (completionBlock) {
                    DISPATCH_ASYNC_MAIN_QUEUE(completionBlock(nil, [NSError errorWithDomain:[NSHTTPURLResponse localizedStringForStatusCode:httpResponse.statusCode]
                                                                                       code:httpResponse.statusCode
                                                                                   userInfo:@{}]));
                }
            }
        } else if (completionBlock) {
            DISPATCH_ASYNC_MAIN_QUEUE(completionBlock(nil, [NSError errorWithDomain:@"Bad Request"
                                                                               code:400
                                                                           userInfo:@{}]));
        }
    }];
    
    NSURLConnection* connection = [[NSURLConnection alloc] initWithRequest:request
                                                                  delegate:connectionDelegateAdapter
                                                          startImmediately:NO];
    [connection setDelegateQueue:[KCSRequest2 requestQueue]];
    [connection start];
}

+(BOOL)isValidMICRedirectURI:(NSString *)redirectURI
                      forURL:(NSURL *)url
{
    return [self isValidMICRedirectURI:redirectURI
                                forURL:url
                                params:nil];
}

+(BOOL)isValidMICRedirectURI:(NSString *)redirectURI
                      forURL:(NSURL *)url
                      params:(NSDictionary**)params
{
    if (![url.absoluteString hasPrefix:redirectURI]) {
        return NO;
    }
    
    NSArray* queryParamsParts = [url.query componentsSeparatedByCharactersInSet:[NSCharacterSet characterSetWithCharactersInString:@"?&"]];
    NSMutableDictionary* queryParams = [NSMutableDictionary dictionary];
    NSArray* keyValue;
    for (NSUInteger i = 0; i < queryParamsParts.count; i++) {
        keyValue = [queryParamsParts[i] componentsSeparatedByString:@"="];
        if (keyValue.count > 0) {
            queryParams[keyValue[0]] = keyValue.count > 1 ? keyValue[1] : @"";
        }
    }
    
    if (params) {
        *params = queryParams;
    }
    
    NSString* code = queryParams[@"code"];
    
    return code != nil && code.length > 0;
}

+(void)parseMICRedirectURI:(NSString *)redirectURI
                    forURL:(NSURL *)url
       withCompletionBlock:(KCSUser2CompletionBlock)completionBlock
{
    NSDictionary* queryParams = nil;
    if ([self isValidMICRedirectURI:redirectURI
                             forURL:url
                             params:&queryParams]) {
        [self oAuthTokenWithCode:queryParams[@"code"]
                     redirectURI:redirectURI
                      completion:completionBlock];
    }
}

+(void)oAuthTokenWithCode:(NSString*)code
              redirectURI:(NSString *)redirectURI
               completion:(KCSUser2CompletionBlock)completionBlock
{
    [self oAuthTokenWithToken:code
                      refresh:NO
                  redirectURI:redirectURI
                   completion:completionBlock];
}

+(void)oAuthTokenWithRefreshToken:(NSString*)refreshToken
                      redirectURI:(NSString*)redirectURI
                             sync:(BOOL)sync
                       completion:(KCSUser2CompletionBlock)completionBlock
{
    [self oAuthTokenWithToken:refreshToken
                      refresh:YES
                  redirectURI:redirectURI
                         sync:sync
                   completion:completionBlock];
}

+(void)oAuthTokenWithToken:(NSString*)token
                   refresh:(BOOL)refresh
               redirectURI:(NSString*)redirectURI
                completion:(KCSUser2CompletionBlock)completionBlock
{
    [self oAuthTokenWithToken:token
                      refresh:refresh
                  redirectURI:redirectURI
                         sync:NO
                   completion:completionBlock];
}

+(void)oAuthTokenWithToken:(NSString*)token
                   refresh:(BOOL)refresh
               redirectURI:(NSString*)redirectURI
                      sync:(BOOL)sync
                completion:(KCSUser2CompletionBlock)completionBlock
{
    NSURL* url = [NSURL URLWithString:[NSString stringWithFormat:@"https://%@.kinvey.com/oauth/token", [self clientConfiguration].authHostname]];
    NSMutableURLRequest* request = [KCSRequest2 requestForURL:url];
    request.HTTPMethod = @"POST";
    
    NSDictionary* bodyParams;
    if (refresh) {
        bodyParams = @{
            @"client_id" : [self clientConfiguration].appKey,
            kKCSMICRedirectURIKey : redirectURI,
            @"grant_type" : @"refresh_token",
            kKCSMICRefreshTokenKey : token
        };
    } else {
        bodyParams = @{
            @"client_id" : [self clientConfiguration].appKey,
            kKCSMICRedirectURIKey : redirectURI,
            @"grant_type" : @"authorization_code",
            @"code" : token
        };
    }
    
    request.HTTPBody = [[self stringFromDictionaryURLEncode:bodyParams] dataUsingEncoding:NSUTF8StringEncoding];
    
    [request setValue:@(request.HTTPBody.length).stringValue
   forHTTPHeaderField:@"Content-Length"];
    
    [request setValue:@"application/x-www-form-urlencoded"
   forHTTPHeaderField:@"Content-Type"];
    
    KCSClientConfiguration* clientConfig = [self clientConfiguration];
    NSString* basicAuthHash = [[[NSString stringWithFormat:@"%@:%@", clientConfig.appKey, clientConfig.appSecret] dataUsingEncoding:NSUTF8StringEncoding] base64EncodedStringWithOptions:0];
    [request setValue:[NSString stringWithFormat:@"Basic %@", basicAuthHash]
   forHTTPHeaderField:@"Authorization"];
    
    void (^block)(NSURLResponse*, NSData*, NSError*) = ^(NSURLResponse *response, NSData *data, NSError *error)
    {
        if (error) {
            if (completionBlock) DISPATCH_ASYNC_MAIN_QUEUE(completionBlock(nil, error));
        } else if ([response isKindOfClass:[NSHTTPURLResponse class]]) {
            NSHTTPURLResponse* httpResponse = (NSHTTPURLResponse*) response;
            if (httpResponse.statusCode == 200 && data) {
                NSDictionary* jsonResponse = [NSJSONSerialization JSONObjectWithData:data
                                                                             options:0
                                                                               error:&error];
                if (error) {
                    if (completionBlock) DISPATCH_ASYNC_MAIN_QUEUE(completionBlock(nil, error));
                } else {
                    NSMutableDictionary* response = [NSMutableDictionary dictionaryWithDictionary:jsonResponse];
                    response[kKCSMICRedirectURIKey] = redirectURI;
                    [self connectWithAuthProvider:KCSSocialIDKinvey
                                 accessDictionary:response
                                       completion:completionBlock];
                }
            } else {
                if (completionBlock) {
                    DISPATCH_ASYNC_MAIN_QUEUE(completionBlock(nil, [NSError errorWithDomain:[NSHTTPURLResponse localizedStringForStatusCode:httpResponse.statusCode]
                                                                                       code:httpResponse.statusCode
                                                                                   userInfo:@{}]));
                }
            }
        } else if (completionBlock) {
            DISPATCH_ASYNC_MAIN_QUEUE(completionBlock(nil, [NSError errorWithDomain:@"Bad Request"
                                                                               code:400
                                                                           userInfo:@{}]));
        }
    };
    
    if (sync) {
        NSURLResponse* response = nil;
        NSError* error = nil;
        NSData* data = [NSURLConnection sendSynchronousRequest:request
                                             returningResponse:&response
                                                         error:&error];
        block(response, data, error);
    } else {
        [NSURLConnection sendAsynchronousRequest:request
                                           queue:[KCSRequest2 requestQueue]
                               completionHandler:block];
    }
}

+(NSString*)stringFromDictionaryURLEncode:(NSDictionary*)dictionary
{
    NSMutableString* result = [NSMutableString string];
    for (NSString* key in dictionary.allKeys) {
        [result appendFormat:@"%@=%@&", [NSString stringByPercentEncodingString:key], [NSString stringByPercentEncodingString:dictionary[key]]];
    }
    if (result.length > 0) {
        [result deleteCharactersInRange:NSMakeRange(result.length - 1, 1)];
    }
    return result;
}

+(NSURL *)URLforLoginWithMICRedirectURI:(NSString *)redirectURI
{
    return [self URLforLoginWithMICRedirectURI:redirectURI
                        authorizationGrantType:KCSMICAuthorizationGrantTypeAuthCodeLoginPage];
}

+(NSURL *)URLforLoginWithMICRedirectURI:(NSString *)redirectURI
                 authorizationGrantType:(KCSMICAuthorizationGrantType)authorizationGrantType
{
    KCSClientConfiguration* config = [KCSClient2 sharedClient].configuration;
    NSMutableString *url = [NSMutableString stringWithFormat:@"https://%@.kinvey.com/oauth/auth", config.authHostname];
    switch (authorizationGrantType) {
        case KCSMICAuthorizationGrantTypeAuthCodeLoginPage:
        {
            NSString* query = [self stringFromDictionaryURLEncode:@{
                @"client_id" : config.appKey,
                kKCSMICRedirectURIKey : redirectURI,
                @"response_type" : @"code"
            }];
            [url appendFormat:@"?%@", query];
            return [NSURL URLWithString:url];
        }
        case KCSMICAuthorizationGrantTypeAuthCodeAPI:
            return [NSURL URLWithString:url];
        default:
            return nil;
    }
}

+ (NSDictionary*) loginDictForProvider:(KCSUserSocialIdentifyProvider)provder accessDictionary:(NSDictionary*)accessDictionary
{
    NSDictionary* dict = @{};
    NSString* accessToken = [accessDictionary objectForKey:KCSUserAccessTokenKey];
    NSString* accessTokenSecret = [accessDictionary objectForKey:KCSUserAccessTokenSecretKey];
    switch (provder) {
        case KCSSocialIDFacebook: {
            NSString* appId = [accessDictionary objectForKey:KCS_FACEBOOK_APP_KEY];
            if (appId == nil) {
                appId = [[KCSClient sharedClient].options objectForKey:KCS_FACEBOOK_APP_KEY];
                if (appId == nil) {
                    appId = [[NSBundle mainBundle] objectForInfoDictionaryKey:@"FacebookAppID"];
                    if (appId == nil) {
                        // could not locate in the access dictionary, client, or plist, error
                        KCSLogWarn(KCS_LOG_CONTEXT_USER, @"No Facebook App Id provided in access dictionary, or KCSClient options key");
                        DBAssert(appId != nil, @"No Facebook App Id provided");
                    }
                }
            }
            dict = appId != nil ?  @{@"_socialIdentity" : @{@"facebook" : @{@"access_token" : accessToken, @"appid" : appId}}} :
            @{@"_socialIdentity" : @{@"facebook" : @{@"access_token" : accessToken}}};
        }
            break;
        case KCSSocialIDTwitter: {
            NSString* twitterKey = [[KCSClient sharedClient].options objectForKey:KCS_TWITTER_CLIENT_KEY];
            NSString* twitterSecret = [[KCSClient sharedClient].options objectForKey:KCS_TWITTER_CLIENT_SECRET];
            DBAssert(twitterKey != nil && twitterSecret != nil, @"twitter info should not be nil.");
            if (twitterKey != nil && twitterSecret != nil) {
                dict = @{@"_socialIdentity" : @{@"twitter" : @{@"access_token" : accessToken,
                                                               @"access_token_secret" : accessTokenSecret,
                                                               @"consumer_key" : twitterKey,
                                                               @"consumer_secret" : twitterSecret}}};
            }
        }
            break;
        case KCSSocialIDLinkedIn: {
            NSString* linkedInKey = [[KCSClient sharedClient].options objectForKey:KCS_LINKEDIN_API_KEY];
            NSString* linkedInSecret = [[KCSClient sharedClient].options objectForKey:KCS_LINKEDIN_SECRET_KEY];
            DBAssert(linkedInKey != nil && linkedInSecret != nil, @"LinkedIn info should not be nil.");
            if (linkedInKey != nil && linkedInSecret != nil) {
                dict = @{@"_socialIdentity" : @{@"linkedIn" : @{@"access_token" : accessToken,
                                                                @"access_token_secret" : accessTokenSecret,
                                                                @"consumer_key" : linkedInKey,
                                                                @"consumer_secret" : linkedInSecret}}};
            }
        }
            break;
        case KCSSocialIDSalesforce: {
            NSString* idUrl = [accessDictionary objectForKey:KCS_SALESFORCE_IDENTITY_URL];
            NSString* refreshToken = [accessDictionary objectForKey:KCS_SALESFORCE_REFRESH_TOKEN];
            NSString* clientId = [accessDictionary objectForKey:KCS_SALESFORCE_CLIENT_ID];
            if (clientId == nil) {
                clientId = [[KCSClient sharedClient].options objectForKey:KCS_SALESFORCE_CLIENT_ID];
            }
            DBAssert(idUrl != nil, @"salesForce info should not be nil.");
            if (idUrl != nil && accessToken != nil) {
                dict = @{@"_socialIdentity" : @{@"salesforce" : @{@"access_token" : accessToken,
                                                                  KCS_SALESFORCE_IDENTITY_URL : idUrl,
                                                                  KCS_SALESFORCE_REFRESH_TOKEN: refreshToken,
                                                                  KCS_SALESFORCE_CLIENT_ID : clientId}}};
            }
            
        }
            break;
        case KCSSocialIDKinvey: {
            dict = @{@"_socialIdentity" : @{@"kinveyAuth" : accessDictionary}};
        }
            break;
        default:
            dict = accessDictionary;
    }
    return dict;
}

#pragma mark - Logout

+ (void) logoutUser:(id<KCSUser2>)user
{
    if (![user isEqual:[KCSUser activeUser]]){
        KCSLogError(KCS_LOG_CONTEXT_USER, @"Attempted to log out a user who is not the KCS Current User!");
    } else {
        
        // Extract all of the items from the Array into a set, so adding the "new" device token does
        // the right thing.  This might be less efficient than just iterating, but these routines have
        // been optimized, we do this now, since there's no other place guarenteed to merge.
        // Login/create store this info
        
        //TODO: comment out to keep the user from being f'ed up. Reinstate once working on the server-side.
        //        KCSDevice *sp = [KCSDevice currentDevice];
        //
        //        if (sp.deviceToken != nil){
        //            NSMutableSet *tmpSet = [NSMutableSet setWithArray:self.deviceTokens];
        //            [tmpSet removeObject:[sp deviceTokenString]];
        //            self.deviceTokens = [tmpSet allObjects];
        //            [self saveToCollection:[KCSCollection userCollection] withCompletionBlock:^(NSArray *objectsOrNil, NSError *errorOrNil) {
        //                if (errorOrNil) {
        //                    KCSLogError(@"Error saving user when removing device tokens: %@", errorOrNil);
        //                }
        //            } withProgressBlock:nil];
        //        }
        [[KCSPush sharedPush] setDeviceToken:nil];
        
        [KCSUser2 clearSavedCredentials];
        [[KCSAppdataStore caches] clear];
        [KCSFileStore clearCachedFiles];
        
        // Set the currentUser to nil
        [self setActive:nil];
    }
}

#pragma mark - User Object Management
+ (void) setupActiveUser:(NSDictionary*)body completion:(KCSUser2CompletionBlock)completionBlock checkAuth:(BOOL) checkAuth
{
    if (![body isKindOfClass:[NSDictionary class]]) {
        //check data type in case server is corrupted, yes this has happened
        NSError* error = [NSError createKCSError:@"Entity dictionary not returned for user" code:401 userInfo:@{@"body":body}];
        completionBlock(nil, error);
        return;
    }
    
    NSString* userId = body[KCSEntityKeyId];
    NSString* username = body [KCSUserAttributeUsername];
    if (userId == nil || username == nil) {
        //prevent that weird assertion that Colden was seeing
        NSError* error = [NSError createKCSError:@"Entity dictionary does not have username or user id" code:401 userInfo:@{@"body":body}];
        completionBlock(nil, error);
        return;
    }
    
    //Strip token
    NSMutableDictionary* modifiedProperties = [body mutableCopy];
    [modifiedProperties removeObjectForKey:KCSUserAttributePassword]; //discard the password in all cases
    
    NSMutableDictionary* metadata = [NSMutableDictionary dictionaryWithDictionary:modifiedProperties[KCSEntityKeyKMD]];
    
    NSString* authToken = nil;
    if (checkAuth) {
        authToken = [metadata popObjectForKey:KCSEntityKeyAuthtoken];
        
        if (authToken == nil) {
            NSError* error = [NSError createKCSError:@"Entity dictionary does not contain an auth token" code:401 userInfo:@{@"body":body}];
            completionBlock(nil, error);
            return;
        }
    }
    
    //Handle Email Verification
    NSDictionary* emailVerification = [metadata popObjectForKey:KCSEntityKeyEmailVerification];
    NSString* verificationStatus = [emailVerification objectForKey:@"status"];
    
    //Put the updated properties back
    modifiedProperties[KCSEntityKeyMetadata] = metadata;
    
    //Make the user object
    KCSCollection* userCollection = [KCSCollection userCollection];
    id<KCSUser2> user = (id<KCSUser2>) [[KCSAppdataStore caches].dataModel objectFromCollection:userCollection.collectionName data:modifiedProperties];
    user.emailVerified = [verificationStatus isEqualToString:@"confirmed"];
    
    if (user.userId == nil || user.username == nil) {
        //prevent that weird assertion that Colden was seeing
        NSError* error = [NSError createKCSError:@"User object not properly configured with _id and username" code:401 userInfo:@{@"body":body}];
        completionBlock(nil, error);
        return;
    }
    
    if (checkAuth) {
        [KCSKeychain2 setKinveyToken:authToken user:userId];
    }
    [self setActive:user];
    [[KCSAppdataStore caches] cacheActiveUser:user];
    
    [[KCSPush sharedPush] registerDeviceToken:^(BOOL success, NSError *error) {
        dispatch_async(dispatch_get_main_queue(), ^{
            completionBlock(user, error);
        });
    }];
}

+ (void)changePasswordForUser:(id<KCSUser2>)user password:(NSString*)newPassword completion:(KCSUser2CompletionBlock)completionBlock
{
    if (newPassword == nil) {
        [[NSException exceptionWithName:NSInvalidArgumentException reason:@"newPassword is nil" userInfo:nil] raise];
    }
    if (![user isEqual:[KCSUser activeUser]]){
        NSDictionary *userInfo = @{NSLocalizedDescriptionKey: @"Receiver is not current user.",
                                   NSLocalizedFailureReasonErrorKey: @"An operation only applicable to the current user was tried on a different user.",
                                   NSLocalizedRecoverySuggestionErrorKey:@"Only perform this action on the active user"};
        NSError *userError = [NSError createKCSError:KCSUserErrorDomain code:KCSOperationRequiresCurrentUserError userInfo:userInfo];
        completionBlock(nil, userError);
    } else {
        KCSCollection* userCollection = [KCSCollection userCollection];
        NSDictionary* entity = [[KCSAppdataStore caches].dataModel jsonEntityForObject:user route:[userCollection route] collection:userCollection.collectionName];
        NSDictionary* body = [entity dictionaryByAddingDictionary:@{KCSUserAttributePassword : newPassword}];
        
        KCSRequest2* request = [KCSRequest2 requestWithCompletion:^(KCSNetworkResponse *response, NSError *error) {
            if (error) {
                KCSLogNSError(KCS_LOG_CONTEXT_USER, error);
                completionBlock(nil, error);
            } else {
                // Ok, we're really auth'd
                NSDictionary* userBody = [response jsonObject];
                [self setupActiveUser:userBody completion:completionBlock checkAuth:YES];
            }
            
        }
                                                            route:KCSRESTRouteUser
                                                          options:@{KCSRequestLogMethod}
                                                      credentials:[KCSUser activeUser]];
        request.method = KCSRESTMethodPUT;
        request.path = @[user.userId];
        request.body = body;
        [request start];
    }
}

+ (void) refreshUser:(id<KCSUser2>)user options:(NSDictionary*)options completion:(KCSUser2CompletionBlock)completionBlock
{
    //options to use in the future for loading references, etc
    if (![user isEqual:[KCSUser activeUser]]){
        KCSLogError(KCS_LOG_CONTEXT_USER, @"Attempted to refresh a user who is not the KinveyKit Active User!");
        NSDictionary *userInfo = @{NSLocalizedDescriptionKey: @"User refresh is not on active user"};
        NSError *userError = [NSError createKCSError:KCSUserErrorDomain code:KCSOperationRequiresCurrentUserError userInfo:userInfo];
        completionBlock(nil, userError);
        return;
    }
    if (user.userId == nil) {
        KCSLogError(KCS_LOG_CONTEXT_USER, @"Error refreshing user, no user id.");
        NSDictionary* errorInfo =  @{NSLocalizedDescriptionKey:@"User has no _id."};
        NSError* error = [NSError createKCSError:KCSUserErrorDomain code:KCSUserObjectNotActiveError userInfo:errorInfo];
        completionBlock(nil, error);
        return;
    }
    
    KCSRequest2* request = [KCSRequest2 requestWithCompletion:^(KCSNetworkResponse *response, NSError *error) {
        if (error) {
            KCSLogError(KCS_LOG_CONTEXT_USER, @"Error Updating user: %@", error);
            dispatch_async(dispatch_get_main_queue(), ^{
                completionBlock(user, error);
            });
        } else {
            if ([KCSUser activeUser] != user) { // still have to check here because active user can be reset while loading request
                KCSLogError(KCS_LOG_CONTEXT_USER, @"Attempted to refresh a user who is not the KinveyKit Active User!");
                NSDictionary *userInfo = @{NSLocalizedDescriptionKey: @"User refresh is not on active user"};
                NSError *userError = [NSError createKCSError:KCSUserErrorDomain code:KCSOperationRequiresCurrentUserError userInfo:userInfo];
                dispatch_async(dispatch_get_main_queue(), ^{
                    completionBlock(user, userError);
                });
            } else {
                NSDictionary* userBody = [response jsonObject];
                [self setupActiveUser:userBody completion:completionBlock checkAuth:NO];
            }
        }
    }
                                                        route:KCSRESTRouteUser
                                                      options:@{KCSRequestLogMethod}
                                                  credentials:user];
    request.path = @[user.userId];
    [request start];
}

+ (void) saveUser:(id<KCSUser2>)user options:(NSDictionary*)options completion:(KCSUser2CompletionBlock)completionBlock
{
    //options for future with references and such
    
    if (![user isEqual:[KCSUser activeUser]]){
        KCSLogError(KCS_LOG_CONTEXT_USER, @"Attempted to save a user who is not the KinveyKit Active User!");
        NSDictionary *userInfo = @{NSLocalizedDescriptionKey: @"Receiver is not current user"};
        NSError *userError = [NSError createKCSError:KCSUserErrorDomain code:KCSOperationRequiresCurrentUserError userInfo:userInfo];
        completionBlock(nil, userError);
        return;
    }
    if (user.userId == nil) {
        KCSLogError(KCS_LOG_CONTEXT_USER, @"Error save user, no user id.");
        NSDictionary* errorInfo =  @{NSLocalizedDescriptionKey:@"User object save needs and established user."};
        NSError* error = [NSError createKCSError:KCSUserErrorDomain code:KCSUserObjectNotActiveError userInfo:errorInfo];
        completionBlock(nil, error);
        return;
    }
    
    NSDictionary* entity = [[KCSAppdataStore caches].dataModel jsonEntityForObject:user route:KCSRESTRouteUser collection:KCSUserCollectionName];
    
    KCSRequest2* request = [KCSRequest2 requestWithCompletion:^(KCSNetworkResponse *response, NSError *error) {
        if (error) {
            KCSLogError(KCS_LOG_CONTEXT_USER, @"Error Updating user: %@", error);
            dispatch_async(dispatch_get_main_queue(), ^{
                completionBlock(user, error);
            });
        } else {
            NSDictionary* userBody = [response jsonObject];
            [self setupActiveUser:userBody completion:completionBlock checkAuth:YES];
        }
    }
                                                        route:KCSRESTRouteUser
                                                      options:@{KCSRequestLogMethod}
                                                  credentials:user];
    request.method = KCSRESTMethodPUT;
    request.path = @[user.userId];
    request.body = entity;
    [request start];
}

+ (void) deleteUser:(id<KCSUser2>)user options:(NSDictionary*)options completion:(KCSCountBlock)completionBlock
{
    if (![user isEqual:[KCSUser activeUser]]){
        KCSLogError(KCS_LOG_CONTEXT_USER, @"Attempted to delete a user who is not the KinveyKit Active User!");
        NSDictionary *userInfo = @{NSLocalizedDescriptionKey: @"Receiver is not current user"};
        NSError *userError = [NSError createKCSError:KCSUserErrorDomain code:KCSOperationRequiresCurrentUserError userInfo:userInfo];
        completionBlock(0, userError);
        return;
    }
    if (user.userId == nil) {
        KCSLogError(KCS_LOG_CONTEXT_USER, @"Error delete user, no user id.");
        NSDictionary* errorInfo =  @{NSLocalizedDescriptionKey:@"User object delete needs and established user."};
        NSError* error = [NSError createKCSError:KCSUserErrorDomain code:KCSUserObjectNotActiveError userInfo:errorInfo];
        completionBlock(0, error);
        return;
    }
    
    KCSRequest2* request = [KCSRequest2 requestWithCompletion:^(KCSNetworkResponse *response, NSError *error) {
        if (error != nil) {
            [self logoutUser:user];
        }
        completionBlock(error != nil, error);
    }
                                                        route:KCSRESTRouteUser
                                                      options:@{KCSRequestLogMethod}
                                                  credentials:user];
    request.method = KCSRESTMethodDELETE;
    request.path = @[user.userId];
    [request start];
}

+ (void) sendPasswordResetForUsername:(NSString*)username completion:(KCSUserSendEmailBlock)completionBlock
{
    // /rpc/:kid/:username/user-password-reset-initiate
    // /rpc/:kid/:email/user-password-reset-initiaxte
    if (username == nil) {
        [[NSException exceptionWithName:NSInvalidArgumentException reason:@"username cannot be nil" userInfo:nil] raise];
    }
    KCSRequest2* request = [KCSRequest2 requestWithCompletion:^(KCSNetworkResponse *response, NSError *error) {
        //response will be a 204 if accepted by server
        completionBlock(response.code == KCS_HTTP_STATUS_NO_CONTENT, error);
    }
                                                        route:KCSRESTRouteRPC
                                                      options:@{KCSRequestLogMethod}
                                                  credentials:[KCSClient2 sharedClient]];
    request.method = KCSRESTMethodPOST;
    request.path = @[username, @"user-password-reset-initiate"];
    [request start];
}

+ (void) sendPasswordResetForEmail:(NSString*)email completion:(KCSUserSendEmailBlock)completionBlock
{
    // /rpc/:kid/:email/user-password-reset-initiate
    if (email == nil) {
        [[NSException exceptionWithName:NSInvalidArgumentException reason:@"email cannot be nil" userInfo:nil] raise];
    }
    KCSRequest2* request = [KCSRequest2 requestWithCompletion:^(KCSNetworkResponse *response, NSError *error) {
        //response will be a 204 if accepted by server
        completionBlock(response.code == KCS_HTTP_STATUS_NO_CONTENT, error);
    }
                                                        route:KCSRESTRouteRPC
                                                      options:@{KCSRequestLogMethod}
                                                  credentials:[KCSClient2 sharedClient]];
    request.method = KCSRESTMethodPOST;
    request.path = @[email, @"user-password-reset-initiate"];
    [request start];
}

+ (void) sendEmailConfirmationForUser:(NSString*)username completion:(KCSUserSendEmailBlock)completionBlock
{
    //req.post /rpc/:kid/:username/user-email-verification-initiate
    if (username == nil) {
        [[NSException exceptionWithName:NSInvalidArgumentException reason:@"username cannot be nil" userInfo:nil] raise];
    }
    KCSRequest2* request = [KCSRequest2 requestWithCompletion:^(KCSNetworkResponse *response, NSError *error) {
        //response will be a 204 if accepted by server
        completionBlock(response.code == KCS_HTTP_STATUS_NO_CONTENT, error);
    }
                                                        route:KCSRESTRouteRPC
                                                      options:@{KCSRequestLogMethod}
                                                  credentials:[KCSClient2 sharedClient]];
    request.method = KCSRESTMethodPOST;
    request.path = @[username, @"user-email-verification-initiate"];
    [request start];
}

+ (void) sendForgotUsernameEmail:(NSString*)email completion:(KCSUserSendEmailBlock)completionBlock
{
    if (email == nil) {
        [[NSException exceptionWithName:NSInvalidArgumentException reason:@"email cannot be nil" userInfo:nil] raise];
    }
    
    KCSRequest2* request = [KCSRequest2 requestWithCompletion:^(KCSNetworkResponse *response, NSError *error) {
        //response will be a 204 if accepted by server
        completionBlock(response.code == KCS_HTTP_STATUS_NO_CONTENT, error);
    }
                                                        route:KCSRESTRouteRPC
                                                      options:@{KCSRequestLogMethod}
                                                  credentials:[KCSClient2 sharedClient]];
    request.method = KCSRESTMethodPOST;
    request.path = @[@"user-forgot-username"];
    request.body = @{@"email" : email};
    [request start];
}

+ (void) checkUsername:(NSString*)potentialUsername completion:(KCSUserCheckUsernameBlock)completionBlock
{
    if (potentialUsername == nil) {
        [[NSException exceptionWithName:NSInvalidArgumentException reason:@"potentialUsername cannot be nil" userInfo:nil] raise];
    }
    
    // /rpc/:appKey/check-username-exists
    KCSRequest2* request = [KCSRequest2 requestWithCompletion:^(KCSNetworkResponse *response, NSError *error) {
        //response will be a 204 if accepted by server
        if (!error) {
            NSDictionary* dict = [response jsonObject];
            completionBlock(potentialUsername, [dict[@"usernameExists"] boolValue], error);
        } else {
            completionBlock(potentialUsername, NO, error);
        }
    }
                                                        route:KCSRESTRouteRPC
                                                      options:@{KCSRequestLogMethod}
                                                  credentials:[KCSClient2 sharedClient]];
    request.method = KCSRESTMethodPOST;
    request.path = @[@"check-username-exists"];
    request.body = @{@"username": potentialUsername};
    [request start];
}

@end
